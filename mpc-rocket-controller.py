# -*- coding: utf-8 -*-

"""
Model Predictive Control (MPC) Rocket Controller

Model Predictive Control (MPC) is used to control a rocket model along the previously generated reference trajectory. 
2-norm MPC is applied to a non-linear rocket model and uses data generated by the "cftoc-landing-trajectory.py" script.
"""

# install required dependencies
from __future__ import division
from scipy import signal
import matplotlib.pyplot as plt
import numpy as np
import polytope as pt
import pyomo.environ as pyo


"""

Program Initialization

"""

# model parameters
m = 27648
l = 70
J = 1 / 16 * m * l**2
g = 9.8

# state = (theta, omega, h, v)
# state constraints
tmin = -20 * np.pi / 180
tmax = 20 * np.pi / 180
zmin = np.array([tmin, -100, -3000, -100])
zmax = np.array([tmax, 100, 0, 500])

# input constraints
Fmax = 2 * 845 * 1000
dmax = 5 * np.pi / 180
umin_original = np.array([0, -dmax])
umax_original = np.array([Fmax, dmax])
Hu = np.array([[1, 0], [-1, 0], [-umax_original[1], 1], [umin_original[1], -1]])
Ku = np.array([umax_original[0], -umin_original[0], 0, 0])

# initial conditions
t0 = 15 * np.pi / 180
v0 = 205
alt0 = 1228
z0 = np.array([t0, 0, -alt0, v0])

# timestep
TS = 0.1

# model
A = np.array([[1, TS, 0, 0], [0, 1, 0, 0], [0, 0, 1, TS], [0, 0, 0, 1]])
B = np.array([[0, 0], [0, -TS / J * (l / 2)], [0, 0], [-TS / m, 0]])
f = np.array([0, 0, 0, TS * g])
nx = 4
nu = 2

# MPC
Q = 10 * np.eye(4)
R = 0 * np.eye(2)
P = 10  # NOTE: this is the MPC horizon, not the terminal cost weight

# length of simulation
N = 100



"""

MPC Vertical Landing Guidance for Non-Linear Rocket Model

"""

# importing reference trajectory
def _generate_data():
  
  with open('rocket_traj.mat', 'wb') as f:
    f.write(data)


_generate_data()
!md5sum rocket_traj.mat

# read the reference trajectory
import scipy.io
ref_traj = scipy.io.loadmat('falcon_traj.mat')
ref_traj['opt_z'].shape # (dimension of state, trajectory length) = (4, 101)

# plot what the reference trajectory looks like
plt.plot(ref_traj['opt_z'][2, :])
plt.show()

# Compute zref: closest to current state z, in height
# idx = np.argmax(ref_traj['opt_z'][2, :] >= z[2])
# zref = ref_traj['opt_z'][:, idx]

# Write your code

# TUNE Q AND R
Q = np.diag([20,15,10,30])
R = np.diag([0,0])

# CFTOC code pulled from HW 6
def solve_cftoc(A, B, Q, R, P, x0, zmin, zmax, Hu, Ku, xref):
    
    model = pyo.ConcreteModel()
    model.P = P
    model.nx = np.size(A, 0)
    model.nu = np.size(B, 1) # no model.nf
    
    # length of finite optimization problem:
    model.tIDX = pyo.Set( initialize= range(model.P+1), ordered=True )  
    model.xIDX = pyo.Set( initialize= range(model.nx), ordered=True )
    model.uIDX = pyo.Set( initialize= range(model.nu), ordered=True )
    
    
    # these are 2d arrays:
    model.A = A
    model.B = B
    model.Q = Q
    model.R = R
    model.Hu = Hu
    model.Ku = Ku
    model.xref = xref

    
    # Create state and input variables trajectory:
    model.x = pyo.Var(model.xIDX, model.tIDX)
    model.u = pyo.Var(model.uIDX, model.tIDX)
    
    #Objective:
    def objective_rule(model):
        costX = 0.0
        costU = 0.0
        costTerminal = 0.0
        for t in model.tIDX:
            for i in model.xIDX:
                for j in model.xIDX:
                    if t < model.P:
                        # costX += model.x[i, t] * model.Q[i, j] * model.x[j, t]
                        costX += (model.x[i, t] - model.xref[i]) * (model.x[j, t] - model.xref[j]) * model.Q[i, j]  # Modified cost uses difference of ref value
        for t in model.tIDX:
            for i in model.uIDX:
                for j in model.uIDX:
                    if t < model.P:
                        costU += model.u[i, t] * model.R[i, j] * model.u[j, t]

        # NO TERMINAL COST ...
        # for i in model.xIDX:
        #     for j in model.xIDX:               
        #         costTerminal += model.x[i, model.N] * model.P[i, j] * model.x[j, model.N]

        return costX + costU # No Terminal Cost Included (+ costTerminal)
    
    model.cost = pyo.Objective(rule = objective_rule, sense = pyo.minimize)
    
    # Constraints:
    def equality_const_rule(model, i, t):
        return model.x[i, t+1] - (sum(model.A[i, j] * model.x[j, t] for j in model.xIDX)
                               +  sum(model.B[i, j] * model.u[j, t] for j in model.uIDX) ) == 0.0 if t < model.P else pyo.Constraint.Skip

    model.equality_constraints = pyo.Constraint(model.xIDX, model.tIDX, rule=equality_const_rule)
    model.init_const1 = pyo.Constraint(expr = model.x[0, 0] == x0[0])
    model.init_const2 = pyo.Constraint(expr = model.x[1, 0] == x0[1])
    model.init_const3 = pyo.Constraint(expr = model.x[2, 0] == x0[2]) 
    model.init_const4 = pyo.Constraint(expr = model.x[3, 0] == x0[3])
    #State constraints for Hu, zmin, zmax
    model.ipstateconstraint5 = pyo.Constraint(model.xIDX, model.tIDX, rule=lambda model, i, t: (model.Hu[i,0] * model.u[0,t]) + (model.Hu[i,1] * model.u[1,t]) <= Ku[i] if t < P else pyo.Constraint.Skip)
    model.constraint6 = pyo.Constraint(model.xIDX, model.tIDX, rule=lambda model, i, t: model.x[i, t] >= zmin[i] if t <= P else pyo.Constraint.Skip) 
    model.constraint7 = pyo.Constraint(model.xIDX, model.tIDX, rule=lambda model, i, t: model.x[i, t] <= zmax[i] if t <= P else pyo.Constraint.Skip)
    
    # NO FINAL CONSTRAINTS
    # def final_const_rule(model, i):
    #     return sum(model.Af[i, j] * model.x[j, model.N] for j in model.xIDX) <= model.bf[i] 
    
    # model.final_const = pyo.Constraint(model.nfIDX, rule=final_const_rule)
    
    solver = pyo.SolverFactory('ipopt')
    results = solver.solve(model)
    
    if str(results.solver.termination_condition) == "optimal":
        feas = True
    else:
        feas = False
            
    xOpt = np.asarray([[model.x[i,t]() for i in model.xIDX] for t in model.tIDX]).T
    uOpt = np.asarray([model.u[:,t]() for t in model.tIDX]).T
    
    JOpt = model.cost()
      
    return [model, feas, xOpt, uOpt, JOpt]

#[model, feas, xOpt, uOpt, JOpt] = solve_cftoc(A, B, P, Q, R, N, x0, xL, xU, uL, uU, bf, Af)

nx = np.size(A, 0)
nu = np.size(B, 1)

xOpt = np.zeros((nx, N+1))
uOpt = np.zeros((nu, N))
xOpt[:, 0] = z0.reshape(nx, )

xPred = np.zeros((nx, P+1, N))
predErr = np.zeros((nx, N-P+1))

feas = np.zeros((N, ), dtype=bool)

#fig = plt.figure(figsize=(9, 6))
for t in range(N):
    [model, feas[t], x, u, J] = solve_cftoc(A, B, Q, R, P, xOpt[:, t], zmin, zmax, Hu, Ku, ref_traj['opt_z'][:,t])
    
    if not feas[t]:
        xOpt = []
        uOpt = []
        predErr = []
        break
    # Save open loop predictions
    xPred[:, :, t] = x

    # Save closed loop trajectory
    # Note that the second column of x represents the optimal closed loop state
    xOpt[:, t+1] = x[:, 1]
    uOpt[:, t] = u[:, 0].reshape(nu, )


# Plots

spacing = np.linspace (0, N * TS, N + 1)

# Plot 1 (States)
plt.figure(figsize=(15,15))

plt.subplot(4, 1, 1)
plt.plot(spacing, ref_traj['opt_z'][0,:],'r--', linewidth = 3, label = 'Reference Trajectory')
plt.plot(spacing, xOpt[0,:], 'b-', linewidth = 3, label = 'MPC Trajectory')
plt.ylabel('Theta')
plt.legend()

plt.subplot(4, 1, 2)
plt.plot(spacing, ref_traj['opt_z'][1,:],'r--', linewidth = 3, label = 'Reference Trajectory')
plt.plot(spacing, xOpt[1,:], 'b-', linewidth = 3, label = 'MPC Trajectory')
plt.ylabel('Omega')
plt.legend()

plt.subplot(4, 1, 3)
plt.plot(spacing, ref_traj['opt_z'][2,:],'r--', linewidth = 3, label = 'Reference Trajectory')
plt.plot(spacing, xOpt[2,:], 'b-', linewidth = 3, label = 'MPC Trajectory')
plt.ylabel('Height')
plt.legend()

plt.subplot(4, 1, 4)
plt.plot(spacing, ref_traj['opt_z'][3,:],'r--', linewidth = 3, label = 'Reference Trajectory')
plt.plot(spacing, xOpt[3,:], 'b-', linewidth = 3, label = 'MPC Trajectory')
plt.ylabel('Velocity')
plt.xlabel('Time (s)')
plt.legend()

# Plot 2 (Force and Delta)
plt.figure(figsize=(15,15))

plt.subplot(3, 1, 1)
plt.plot(spacing[0:-1], uOpt[0,:], 'b-', linewidth = 3)
plt.ylabel('F')

plt.subplot(3, 1, 2)
plt.plot(spacing[0:-1], (180 / np.pi) * (uOpt[1,:] / uOpt[0,:]), 'b-', linewidth = 3) # In Degrees
plt.ylabel('Delta')
plt.xlabel('Time (s)')

plt.show()

# Show set U of input constraints - Part C

U = pt.Polytope(Hu,Ku)

fig, ax = plt.subplots()
U.plot(ax)
ax.set_xlabel('F')
ax.set_ylabel('F * Delta')
ax.axis('equal')
plt.show()
